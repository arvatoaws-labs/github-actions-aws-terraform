name: 'TerraformApply'

on:
  issue_comment:
    types: [created]
  workflow_call:
    inputs:
      region:
        required: true
        type: string
      terraform_version:
        required: true
        type: string
      roleArn:
        required: true
        type: string
      s3bucketName:
        required: true
        type: string
      github_event_number:
        required: true
        type: string
      github_event_issue_url:
        required: true
        type: string
      github_event_issue_comments_url:
        required: true
        type: string
      github_event_repository_url:
        required: true
        type: string


jobs:
  terraform:
    name: 'Apply Terraform'
    runs-on: ubuntu-latest
    outputs:
      output1: ${{ steps.job.outputs.job_id }}
    permissions:
      actions: read
      id-token: write
      contents: write
      pull-requests: write
    defaults:
      run:
        shell: bash

    steps:
    # Expose and capture the job ID of the current job
    - uses: ReeganExE/github-action-job-id@v1.0
    - name: Job ID output
      id: job
      run: |
        echo ${GH_JOB_0_ID}
        echo "job_id=$GH_JOB_0_ID" >> $GITHUB_OUTPUT

    # Assume the role in AWS to roll out the changes
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-region: ${{ inputs.region }}
        role-to-assume: ${{ inputs.roleArn }}
        role-session-name: GitHubTerraformDeployment

    # Get the github token with access to the relevant repositories from the app
    - name: Generate token
      id: generate-token
      uses: tibdex/github-app-token@v1
      with:
        app_id: ${{ secrets.TERRAFORM_GITHUB_ACTION_APP_ID }}
        private_key: ${{ secrets.TERRAFORM_GITHUB_ACTION_PRIVATE_KEY }}

    # Configure github access
    - uses: de-vri-es/setup-git-credentials@v2
      with:
        credentials: https://oauth:${{ steps.generate-token.outputs.token }}@github.com/

    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3
      with:
        ref: refs/pull/${{ inputs.github_event_number }}/merge

    # Install the latest version of Terraform CLI
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: ${{ inputs.terraform_version }}

    # Initialize Terraform
    - name: Terraform Init
      run: terraform init -upgrade

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format LandingZone
      run: terraform fmt -check

    # Download the plan from S3
    - name: Download Plan from S3
      run: |
        aws s3 cp s3://${{ inputs.s3bucketName }}/plans/tfplan ./tfplan

    # Build or change infrastructure according to Terraform configuration files
    - name: Terraform Apply
      id: apply
      continue-on-error: true
      run: |
        terraform apply -input=false -no-color tfplan
    # Upload the plan to S3
    - name: Upload Plan to S3
      run: |
        aws s3 cp ./tfplan s3://${{ inputs.s3bucketName }}/plans/

    # CONCLUDE
    # If the apply was successful, post a comment with the applied output
    - name: Post Plan and Apply to GitHub PR
      if: steps.apply.outcome == 'success'
      env:
        URL: ${{ inputs.github_event_issue_comments_url }}
        LABEL: ${{ inputs.github_event_issue_url }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        (printf "Mode1 Apply\n\n\`\`\`" && echo -n '${{ steps.apply.outputs.stdout }}' && printf "\`\`\`\n\n") > comment.txt
        jq -R -s '.' < comment.txt > comment2.txt
        truncate -s -1 comment2.txt
        (echo -n '{ "body": ' && cat comment2.txt && echo -n ' }') > comment3.txt
        curl \
          -X POST \
          $URL \
          -H "Content-Type: application/json" \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -d @comment3.txt
        curl \
          -X POST \
          $LABEL/labels \
          -H "Content-Type: application/json" \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -d '["applied"]'

    # If the apply was successful, merge the branch into the main
    - name: Merge into main
      if: steps.apply.outcome == 'success'
      env:
        URL: ${{ inputs.github_event_repository_url }}/pulls/${{ inputs.github_event_number }}/merge
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        curl \
        -X PUT \
        $URL \
        -H "Content-Type: application/json" \
        -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
        -d '{"commit_title":"terraform update applied"}'

    # remove the organization plan from S3 whether successful or not
    - name: Delete Plan from S3
      run: |
        aws s3 rm s3://${{ inputs.s3bucketName }}/plans/tfplan

    # If the apply failed, post the errors
    - name: Post Organization Apply Failure
      if: steps.apply.outcome == 'failure'
      env:
        URL: ${{ inputs.github_event_issue_comments_url }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        (printf "Apply failed for Mode1:\n\nMode1\n\n\`\`\`" && echo -n '${{ steps.apply.outputs.stderr }}' && printf "\`\`\`\n\n") > comment.txt
        jq -R -s '.' < comment.txt > comment2.txt
        truncate -s -1 comment2.txt
        (echo -n '{ "body": ' && cat comment2.txt && echo -n ' }') > comment3.txt
        curl \
          -X POST \
          $URL \
          -H "Content-Type: application/json" \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -d @comment3.txt

  logging:
    name: 'Save logs'
    needs: terraform
    runs-on: ubuntu-latest
    if: always() # This job will always run
    permissions:
      actions: read
      id-token: write
      contents: read
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    # Assume the role in AWS to upload the logs
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-region: ${{ inputs.region }}
        role-to-assume: ${{ inputs.roleArn }}

    # Save previous job logs and upload to s3
    - name: Retrieve log file and upload to s3
      run: |
        TIMESTAMP=$(date +'%Y-%m-%d-%H:%M:%S')
        LOG_FILENAME="TerraformApply_${{ inputs.github_event_number }}_PR_$TIMESTAMP.txt"
        # Get log file
        gh api repos/{owner}/{repo}/actions/jobs/${{ needs.terraform.outputs.output1 }}/logs > $LOG_FILENAME
        # Upload it to s3
        aws s3 cp $LOG_FILENAME s3://${{ inputs.s3bucketName }}/logs/Apply/
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}